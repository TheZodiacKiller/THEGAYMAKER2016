<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_Level</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Create text
instance_create(view_xport[0] + view_wview[0]/2,view_yport[0] + 32,o_floortext);


//
if room == t1r1 || room == t1r2 || room == t1r3 || room == t1boss {
    bgfloor = bg_stonefloor;
    bgtiles = bg_stonetiles;
    theme = 1;
    }
if room == t2r1 || room == t2r2 || room == t2r3 || room == t2boss {
    bgfloor = bg_icefloor;
    bgtiles = bg_icetiles;
    theme = 2;
    }
if room == t3r1 || room == t3r2 || room == t3r3 {
    bgfloor = bg_hellfloor;
    bgtiles = bg_helltiles;
    theme = 3;
    }
if room == t4r1 || room == t4r2 || room == t4r3 {
    bgfloor = bg_fleshfloor;
    bgtiles = bg_fleshtiles;
    theme = 4;
    }
if room == t5r1 || room == t5r2 || room == t5r3 {
    bgfloor = bg_shadowfloor;
    bgtiles = bg_shadowtiles;
    theme = 5;
    }
if room == shop1 || room == shop2 || room == shop3 || room == shop4 || room == shop5 {
    bgfloor = bg_purgatoryfloor;
    bgtiles = bg_purgatorytiles;
    theme = 6;
    }
var oddss = 600;
var spawn = false;
///// Construct the Level /////

// Resize the room
if room != t1boss || room != t2boss || room != shop1 || room != shop2 || room != shop3 || room != shop4 || room != shop5{
room_width = (CELL_WIDTH/16) * 600;
room_height = (CELL_HEIGHT/16) * 600;
}
if room == t1boss || room == t2boss {
room_width = (CELL_WIDTH/16) * 240;
room_height = (CELL_HEIGHT/16) * 240;
}
if room == shop1 || room == shop2 || room == shop3 || room == shop4 || room == shop5 {
room_width = (CELL_WIDTH/16) * 120;
room_height = (CELL_WIDTH/16) * 120;
}

//Set grid WIDTH and HEIGHT
//div means that it will divide var 1 by var 2 and round to a full number
var width = room_width div CELL_WIDTH;
var height = room_height div CELL_HEIGHT;

// Create the Grid
grid = ds_grid_create(width, height);
//Create pathfinding grid for enemies
grid_path = mp_grid_create(0,0, width, height, CELL_WIDTH, CELL_HEIGHT);


//Fill the grid with the VOID
//ds_grid_set_region sets all the tiles to a specific value
//These values are per cell, not pixel due to the grid variable.
ds_grid_set_region(grid,0, 0, width-1, height-1, VOID);

// Randomize the WORLD
randomize();


// Creates the Controller at the center of the Grid
var cx = width div 2;
var cy = height div 2;

//Create the player
//Warriors
if o_characterpicker.warrior = 1
    instance_create(cx*CELL_WIDTH+CELL_WIDTH/2, cy*CELL_HEIGHT+CELL_HEIGHT/2, o_warrior);
if o_characterpicker.berserker = 1
    instance_create(cx*CELL_WIDTH+CELL_WIDTH/2, cy*CELL_HEIGHT+CELL_HEIGHT/2, o_berserker);
if o_characterpicker.crusader = 1
    instance_create(cx*CELL_WIDTH+CELL_WIDTH/2, cy*CELL_HEIGHT+CELL_HEIGHT/2, o_crusader);
//Archers
if o_characterpicker.archer = 1
    instance_create(cx*CELL_WIDTH+CELL_WIDTH/2, cy*CELL_HEIGHT+CELL_HEIGHT/2, o_archer);
if o_characterpicker.sniper = 1
    instance_create(cx*CELL_WIDTH+CELL_WIDTH/2, cy*CELL_HEIGHT+CELL_HEIGHT/2, o_sniper);
if o_characterpicker.hunter = 1
    instance_create(cx*CELL_WIDTH+CELL_WIDTH/2, cy*CELL_HEIGHT+CELL_HEIGHT/2, o_hunter);
//ROGUES
if o_characterpicker.rogue = 1
    instance_create(cx*CELL_WIDTH+CELL_WIDTH/2, cy*CELL_HEIGHT+CELL_HEIGHT/2, o_rogue);
if o_characterpicker.bladedancer = 1
    instance_create(cx*CELL_WIDTH+CELL_WIDTH/2, cy*CELL_HEIGHT+CELL_HEIGHT/2, o_bladedancer);
if o_characterpicker.assassin = 1
    instance_create(cx*CELL_WIDTH+CELL_WIDTH/2, cy*CELL_HEIGHT+CELL_HEIGHT/2, o_assassin);
//MAGES
if o_characterpicker.mage = 1
    instance_create(cx*CELL_WIDTH+CELL_WIDTH/2, cy*CELL_HEIGHT+CELL_HEIGHT/2, o_mage);
if o_characterpicker.firemagi = 1
    instance_create(cx*CELL_WIDTH+CELL_WIDTH/2, cy*CELL_HEIGHT+CELL_HEIGHT/2, o_firemagi);
if o_characterpicker.frostwizard = 1
    instance_create(cx*CELL_WIDTH+CELL_WIDTH/2, cy*CELL_HEIGHT+CELL_HEIGHT/2, o_frostwizard);
    
    //Build the shop
if theme = 6 {
    instance_create((cx-2)*CELL_WIDTH+CELL_WIDTH/2, cy*CELL_HEIGHT+CELL_HEIGHT/2, o_shopkeeper);
    instance_create((cx-2)*CELL_WIDTH+CELL_WIDTH/2, (cy-1)*CELL_HEIGHT+CELL_HEIGHT/2, o_dmgupgrade);
    instance_create(cx*CELL_WIDTH+CELL_WIDTH/2, (cy-1)*CELL_HEIGHT+CELL_HEIGHT/2, o_hpupgrade);
    instance_create((cx+2)*CELL_WIDTH+CELL_WIDTH/2, (cy-1)*CELL_HEIGHT+CELL_HEIGHT/2, o_spdupgrade);
    instance_create((cx+2)*CELL_WIDTH+CELL_WIDTH/2, cy*CELL_HEIGHT+CELL_HEIGHT/2, o_spellupgrade);
    instance_create((cx+2)*CELL_WIDTH+CELL_WIDTH/2, (cy+1)*CELL_HEIGHT+CELL_HEIGHT/2, o_mpupgrade);
    
    instance_create(cx*CELL_WIDTH+CELL_WIDTH/2, (cy-2)*CELL_HEIGHT+CELL_HEIGHT/2, o_stairs);
    }
    

// Give the Controller a random direction
// Four-directional input: 0,1,2,3 * 90 = direction in degrees.
var cdir = irandom(3);

var odds = 1;

// Creates the level using 1000 steps
// Sets down the tiles
repeat (1000) {
    //Places floor tile at controller position
    // # = accessor
    grid[# cx, cy] = FLOOR;
    
    
    //Randomize Controller direction
    //Selects a random value up to 1: 0 or 1. If odds are set to 1 (50% chance), change direction.
    if (irandom(odds) == odds) {
        cdir = irandom(3);
    
    }
    //Moves the Controller
    var xdir = lengthdir_x(1, cdir*90);
    var ydir = lengthdir_y(1, cdir*90);
    cx += xdir;
    cy += ydir;
  
    //Makes sure the Controller doesn't exit world boundries
    //Creates a one cell border, creating a wall if floor attemps to connect to wall boundry
    cx = clamp(cx, 1, width-2);
    cy = clamp(cy, 1, height-2);
    
    
    
    
}
//Checks where floor ends and add walls
for (var yy = 1; yy &lt; height-1; yy++) {
    for (var xx = -1; xx &lt; width-1; xx++) {
        if (grid[# xx, yy] == FLOOR) {
        ///Checks for walls
            //Checks the Right side
            if (grid[# xx+1, yy] != FLOOR) { grid [# xx+1, yy] = WALL;
            
            }
            //Checks the Left Side
            if (grid[# xx-1, yy] != FLOOR) { grid [# xx-1, yy] = WALL;
            
            }
            //Checks Below
            if (grid[# xx, yy+1] != FLOOR) { grid [# xx, yy+1] = WALL;
            
            }
            //Checks Above
            if (grid[# xx, yy-1] !=FLOOR) { grid [# xx, yy-1] = WALL;
            
            }
        }            
        
    }
}

//Clean up walls (Remove SINGLE WALLS)
for (var yy = 1; yy &lt; height-1; yy++) {
    for (var xx = 1; xx &lt; width-1; xx++) {
        if (grid[# xx+1, yy] == WALL &amp;&amp; grid[# xx-1, yy] == FLOOR &amp;&amp; grid[# xx, yy+1] == FLOOR &amp;&amp; grid[# xx, yy+1] == FLOOR) {
            grid[# xx, yy] = FLOOR;
            }
        }
    }


//Loops through entire grid, not just where floor is
//Draws the level
for (var yy = 0; yy &lt; height; yy++) {
    for (var xx = 0; xx &lt; width; xx++) {
        if (grid[# xx, yy] == FLOOR) {
            //Draws the Floor
            //B/c the grid is set up as indexes, xx*CELL_WIDTH means that the image is being positioned at where the Grid places the CELL_WIDTH, same for CELL_HEIGHT
            tile_add(bgfloor, 0, 0, CELL_WIDTH, CELL_HEIGHT, xx*CELL_WIDTH, yy*CELL_HEIGHT, 0)
            
            //Creates enemies
            var enemy = irandom_range(1,200);
            var odds = 80;
            var chest = 250;
            var echest = 600;
            var uchest = 1000;
            var ex = xx*CELL_WIDTH+CELL_WIDTH/2
            var ey = yy*CELL_HEIGHT+CELL_HEIGHT/2
            if theme = 1
                if (point_distance(ex, ey, o_player.x, o_player.y) &gt; 80) &amp;&amp; enemy &gt;= 1 &amp;&amp; enemy &lt;= 7 
                    instance_create(ex, ey, choose(o_seeker,o_bat,o_zombie));
            if theme = 2
                if (point_distance(ex, ey, o_player.x, o_player.y) &gt; 80) &amp;&amp; enemy &gt;= 1 &amp;&amp; enemy &lt;= 7
                    instance_create(ex, ey, choose(o_icemage,o_slider));                                                                
            if theme = 3
                if (point_distance(ex, ey, o_player.x, o_player.y) &gt; 80) &amp;&amp; enemy &gt;= 1 &amp;&amp; enemy &lt;= 7
                    instance_create(ex, ey, choose(o_imp,o_flyerimp));
            if theme = 4
                if (point_distance(ex, ey, o_player.x, o_player.y) &gt; 80) &amp;&amp; enemy &gt;= 1 &amp;&amp; enemy &lt;= 7
                    instance_create(ex, ey, choose(o_fleshling,choose(o_fleshling,o_fleshward)));
            if theme = 5
                if (point_distance(ex, ey, o_player.x, o_player.y) &gt; 80) &amp;&amp; enemy &gt;= 1 &amp;&amp; enemy &lt;= 7
                    instance_create(ex, ey, o_wraith);
            
                
            //Create enemy spawns    
            if (point_distance(ex, ey, o_player.x, o_player.y) &gt; 80) &amp;&amp; irandom(odds) == odds {
                instance_create(ex, ey, o_enemyspawn);
            }
                
            //Create Exit Stairs
            if (point_distance(ex, ey, o_player.x, o_player.y) &gt; 320) &amp;&amp; spawn == false {
                spawn = true;
                instance_create(ex, ey, o_stairs);
                }
             //Create Chests
             if theme = 1 {
                 if (point_distance(ex, ey, o_player.x, o_player.y) &gt; 80) &amp;&amp; irandom(chest) == chest  
                    instance_create(ex,ey, o_woodchest);
                
                
                 if (point_distance(ex, ey, o_player.x, o_player.y) &gt; 80) &amp;&amp; irandom(uchest) == uchest &amp;&amp; irandom(chest) != chest 
                    instance_create(ex,ey, o_goldchest);
                    }
                 
             if theme = 2 {
                 if (point_distance(ex, ey, o_player.x, o_player.y) &gt; 80) &amp;&amp; irandom(chest) == chest  
                        instance_create(ex,ey, o_icechest);
                 
                
                 if (point_distance(ex, ey, o_player.x, o_player.y) &gt; 80) &amp;&amp; irandom(echest) == echest &amp;&amp; irandom(chest) != chest 
                    instance_create(ex,ey, o_epicicechest);
                    
                 if (point_distance(ex, ey, o_player.x, o_player.y) &gt; 80) &amp;&amp; irandom(uchest) == uchest &amp;&amp; irandom(chest) != chest &amp;&amp; irandom(echest) != echest
                    instance_create(ex,ey, o_epicicechest);
                 }
            
        } else {
            mp_grid_add_cell(grid_path, xx, yy);
        }
    }
}

//Recieve tile sizes
var tw = CELL_WIDTH/2;
var th = CELL_HEIGHT/2;

//Add the tiles
//times 2 b/c since visual tiles are half size of grid, it is required to apply twice.
for (var yy = 00; yy &lt; height*2; yy++) {
    for (var xx = 0; xx &lt; width*2; xx++) {
        if (grid[# xx div 2, yy div 2] == FLOOR) {
            // Get tile's x &amp; y position
            var tx = xx*tw
            var ty = yy*th
            
            //Check left, right, up, down and the corners (checking 1/16 cell to the DIRECTION). Check then Convert
            var right = grid[# (xx+1) div 2, yy div 2] != FLOOR;
            var left = grid[# (xx-1) div 2, yy div 2] != FLOOR;
            var top = grid[# xx div 2, (yy-1) div 2] != FLOOR;
            var bottom = grid[# xx div 2, (yy+1) div 2] != FLOOR;
            
            var top_right = grid[# (xx+1) div 2, (yy-1) div 2] != FLOOR;
            var top_left = grid[# (xx-1) div 2, (yy-1) div 2] != FLOOR;
            var bottom_right = grid[# (xx+1) div 2, (yy+1) div 2] != FLOOR;
            var bottom_left = grid[# (xx-1) div 2, (yy+1) div 2] != FLOOR;
            
            
            //// (tileset, tile position on tileset (x), (y), location on grid (x), (y), depth)
            //Right side Check
            if (right) { 
            
                if (bottom) {
                    tile_add(bgtiles, tw*4, th*1, tw, th, tx+tw, ty, -ty);
                } else if (top) {
                    if (top_right) {
                        tile_add(bgtiles, tw*4, th*0, tw, th, tx+tw, ty-th, -ty);
                    } else {
                        tile_add(bgtiles, tw*3, th*0, tw, th, tx, ty-th, -ty);
                    }
                    tile_add(bgtiles, tw*0, th*1, tw, th, tx+tw, ty, -ty);
                } else {
                    tile_add(bgtiles, tw*0, th*1, tw, th, tx+th, ty, -ty);
                }
            }
            //Left Side Check
            if (left) {
            
                if (bottom) {
                    tile_add(bgtiles, tw*3, th*1, tw, th, tx-tw, ty, -ty);
                } else if (top) {
                    if (top_left) {
                        tile_add(bgtiles, tw*3, th*0, tw, th, tx-tw, ty-th, -ty);
                } else {
                    tile_add(bgtiles, tw*4, th*0, tw, th, tx, ty-th, -ty);
                }
                tile_add(bgtiles, tw*2, th*1, tw, th, tx-tw, ty, -ty);
            } else {
                tile_add(bgtiles, tw*2, th*1, tw, th, tx-tw, ty, -ty);
            
                }
            }
            
            //Top Side Check
            if (top) {
            
                if (!top_right) {
                    tile_add(bgtiles, tw*2, th*2, tw, th, tx, ty-th , -ty);    
                
                } else if (!top_left) {
                    tile_add(bgtiles, tw*0, th*2, tw, th, tx, ty-th , -ty);
                
                } else {
                    tile_add(bgtiles, tw*1, th*2, tw, th, tx, ty-th , -ty);
                }
            }
            
            //Bottom Side Check
            if (bottom) {
            
                if (!bottom_right) {
                    tile_add(bgtiles, tw*2, th*0, tw, th, tx, ty , -ty-tw);    
                
                } else if (!bottom_left) {
                    tile_add(bgtiles, tw*0, th*0, tw, th, tx, ty , -ty-tw);
                
                } else {
                    tile_add(bgtiles, tw*1, th*0, tw, th, tx, ty , -ty-tw);
                }
            }
                
        }
    }
}            












</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Destroy grids
ds_grid_destroy(grid);
mp_grid_destroy(grid_path);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>room_restart();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="27">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>instance_create(x,y,o_pause);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="17">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if room_next(room) != -1
    {
    room_goto(room_next(room));
    o_player_stats.increase += 1;
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
